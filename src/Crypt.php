<?php namespace KernelCurry\ClickerHeroes;

/**
 * Cryptography class that takes care of encryption
 * and decryption of game saves.
 *
 * @package  Clicker Heroes API
 * @author   Michael Curry <kernelcurry@gmail.com>
 */

class Crypt
{
	/**
	 * Encrypted save.
	 *
	 * @var mixed|string
	 */
	private $encrypted = null;

	/**
	 * Decrypted stdClass of the encrypted save.
	 *
	 * @var mixed|\stdClass
	 */
	private $decrypted = null;

	/**
	 * Known salts per version.
	 *
	 * @var array
	 */
	private $known_salts = [
		'af0ik392jrmt0nsfdghy0' // version 0.14
	];

	/**
	 * Salt that is found to work in with the
	 * encrypted save.
	 *
	 * @var mixed
	 */
	private $salt = null;

	/**
	 * Known salts per version.
	 *
	 * @var array
	 */
	private $known_delimiters = [
		'Fe12NAfA3R6z4k0z' // version 0.14
	];

	/**
	 * Anti-cheat delimiter that is placed between
	 * the game data and the hack check.
	 *
	 * @var mixed|string
	 */
	private $delimiter = null;

	/**
	 * This function uses a game save to populate
	 * remaining variables.
	 *
	 * @param string $value
	 * @return $this
	 */
	public function decrypt($value)
	{
		// Add reset function before decrypting

		$this->encrypted = $value;
		$this->findDelimiter()->crack();

		return $this->decrypted;
	}

	/**
	 * Find and sent the current anti-cheat delimiter.
	 *
	 * @return $this
	 */
	private function findDelimiter()
	{
		$this->delimiter = substr($this->encrypted, strlen($this->encrypted) - 48, 16);

		return $this;
	}

	/**
	 * Crack encrypted save. If the save can not be cracked,
	 * (bool)false will bre returned.
	 *
	 * @return $this
	 * @throws \Exception
	 */
	private function crack()
	{
		$result = explode($this->delimiter,$this->encrypted);

		foreach ($this->known_salts as $salt)
		{
			// Stitch together the 64bit encoded saved
			// game by taking every other character
			// from the encrypted save.
			$check = '';
			for ($i = 0; $i < strlen($result[0]); $i += 2)
			{
				$check .= $result[0][$i];
			}

			// Check to see if the save was correctly
			// cracked by checking to see if the md5
			// of the check + salt matched the md5
			// generated by the game upon export.
			$hash = md5($check . $salt);
			if ( $hash == $result[1]) {
				$this->salt = $salt;
				$this->decrypted = json_decode(base64_decode($check));

				return $this;
			}
		}

		// If this return is reached, an error has
		// occurred while cracking the game save.
		throw new \Exception('Cracking Error');
	}

	/**
	 * Take the game save stdClass and encrypt for use
	 * in the game.
	 *
	 * @param \stdClass $value
	 * @return string
	 */
	public function encrypt($value)
	{
		// Encode the save stdClass and generate the
		// hash check for the game to validate.
		$new = base64_encode(json_encode($value));
		$hash = md5($new . $this->getCurrentSalt());
		$new_save = '';

		// Pad the 64bit encoded save and add the required
		// delimiter for the game import properly.
		for ($i = 0; $i < strlen($new); $i++)
		{
			$new_save .= $new[$i].$this->randomCharacter();
		}
		$new_save .= $this->getCurrentDelimiter();
		$new_save .= $hash;

		return $new_save;
	}

	/**
	 * Returns the most current know salt for encryption.
	 *
	 * @return string
	 */
	private function getCurrentSalt()
	{
		return end(array_values($this->known_salts));
	}

	/**
	 * Returns the most current know anti-cheat delimiter
	 * for encryption.
	 *
	 * @return string
	 */
	private function getCurrentDelimiter()
	{
		return end(array_values($this->known_delimiters));
	}

	/**
	 * Returns one single random character
	 *
	 * @return string
	 */
	private function randomCharacter()
	{
		$characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		return $characters[mt_rand(0,strlen($characters)-1)];
	}
}